This section describes the data model for how resources are organized within LWS. It covers how containers and resources are structured, the hierarchical relationships between them, the semantics of containers (which are like folders or collections), containment rules, and how clients can organize and navigate collections of resources. Essentially, this defines the **logical namespace** of the storage and how resources relate to each other in that namespace.

**Resource:** In LWS, a *resource* is the basic unit of storage and access. Each resource has a unique identifier within the system (for example, a URI or path). A resource can hold data (such as a file’s contents or a piece of structured information) and metadata (like its type or last modified time). There are two broad kinds of resources: container resources and non-container resources. A **non-container resource** is an indivisible item (analogous to a file or document); it does not contain other resources.

**Container:** A *container* is a special type of resource that can contain other resources. Containers serve as the organizational units (similar to directories or folders in a file system). A container can hold references to member resources, which may include both non-container resources (files) and other container resources (sub-folders). This forms a hierarchy or tree structure. A container typically has no large content of its own (beyond perhaps some metadata or a listing of its children) – its primary purpose is to group and organize other resources. The **root of the storage** is defined as a container (the top-level container that has no parent, see below).

**Containment and Hierarchy:** Every resource (except the root container) is contained within exactly one parent container. This means the organizational structure is a strict hierarchy (a tree) with a single root container at the top. If a resource is created in container A, then container A is its parent in the hierarchy, and that resource will appear in A’s listing. A resource’s full identifier often reflects this hierarchy (for example, a resource’s identifier might be a path like `/alice/notes/shoppinglist.txt` indicating that `shoppinglist.txt` is contained in the `notes` container, which in turn is under the `alice` container, etc.). Cycles or multiple parentage are not allowed in this containment model; one resource cannot simultaneously reside in two containers – it would need to be duplicated or referenced in some other way outside the core containment structure. This rule simplifies the model and aligns with typical file-system semantics.

**Container Membership Management:** Creating, deleting, or moving resources affects container membership:

* When a new resource is **created**, it is placed into a specified container (either explicitly provided or implied by the target identifier). That container’s membership now includes the new resource. The act of creation may also involve creating intermediate containers if the path implies them and they don’t exist (though typically creation expects the parent container to already exist, unless the implementation supports auto-creating missing containers).

* When a resource is **deleted**, it is removed from its parent container’s membership. If it was the last remaining member of that container, the container becomes empty (which may then allow deletion of that container if desired). Deleting a container itself (as discussed in the operations) usually requires it to be empty, or else a recursive deletion is performed to also remove its members.

* Currently, the core operations defined (create, read, update, delete) do not include an explicit “move” or “rename” operation. To move a resource from one container to another, a client would typically perform a copy (or re-create) in the new location and then delete the original. Some implementations may provide a non-core convenience operation for moving or renaming, but logically it can be achieved through create and delete.

**Container Creation:** A container is created via the same *create resource* operation, distinguished by a flag or context indicating that the new resource is to be a container rather than a regular file. In practice, this could be done by sending a create request with an empty body (and perhaps a header indicating the intent to create a container), or by using a specific media type or convention. For example, an API might treat any new resource whose identifier ends with a `/` as a container, or require a special container content type. Regardless of how it’s signaled, creating a container results in a new empty container resource that can then hold children. Once a container exists, clients can create new resources inside it, or even create sub-containers within it (thereby extending the hierarchy further).

**Navigating and Listing Resources:** Clients can navigate the hierarchy by performing read operations on containers to retrieve their listings (as described in the read operation). A container’s representation will enumerate the identifiers (or names and perhaps types) of its member resources. This allows clients to discover what resources exist, mimic folder navigation, and construct URLs or requests to delve deeper into the hierarchy. The protocol may allow different representations of a container’s listing (for example, a human-friendly HTML index, or a machine-readable JSON or RDF serialization). The ability to list container contents means that well-behaved servers should update container listings promptly when members are added or removed, keeping the hierarchy consistent.

**Hierarchical Naming:** Within any given container, each child resource **MUST have a unique name or identifier** that distinguishes it from other siblings. Resource names within a container **MUST** be treated as case-sensitive by the server.  The combination of the container’s identifier and the resource’s name forms the resource’s full path (identifier). This hierarchical naming is what allows the logical organization to be reflected in resource identifiers such as URIs.

**Relationship to Linked Data (Optional):** While LWS is not limited to Linked Data or RDF, it can be extended or configured to support semantic descriptions of resources. For example, a container might have an RDF graph describing its members and relationships (as in Solid or LDP containers), and resources could have RDF metadata. However, this is **optional** and not required for basic operation. The core specification treats containers and resources in a generic way so that a broad range of applications (not just those using RDF) can adopt it. An implementation may choose to expose RDF views or Linked Data features (like identifying certain resources as RDF resources, or supporting queries), but these would be additional layers on top of the fundamental storage model described here.

In summary, the logical organization in LWS is akin to a directory tree: containers are directories, resources are files, each resource knows which container is its parent, and containers provide a way to traverse and manage groups of resources. This organization enables clients to structure their data in an intuitive way and navigate through it using the defined operations.